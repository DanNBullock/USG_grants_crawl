"""
This set of functions is for the production of figures


"""

def plotNullValue_barPlot(dataCompletenessDF, logScale=None,figSize=None, fig=None, ax=None,savePath=None):
    """
    This function takes in the table generated by analyzeData.quantifyDataCompleteness, which outputs:

    dataCompletenessDF : pandas dataframe
        A pandas dataframe with two columns:  the first column is the field name and the second column is the number of empty / null values for that field.
        The last row is the total number of records assessed.

    and produces a seaborn-based bar plot of the number of null values for each field.
    The last row is omitted from the plot, as it is the total number of records assessed, 
    but it is used to set the y-axis limits.

    Input:
        dataCompletenessDF : pandas dataframe
            A pandas dataframe with two columns:  the first column is ('fieldName'): the field name and the second column ('numEmpty') is the number of empty / null values for that field.
            The last row is the total number of records assessed.  Generated by analyzeData.quantifyDataCompleteness
        logScale : boolean
            A boolean indicating whether or not to plot the y axis on a log scale.  If True, the y axis is plotted on a log scale.  If False, the y axis is plotted on a linear scale.
            If None, the y axis is plotted on a log scale if the difference between the smallest non-zero value and the max value is equal to or greater than three orders of magnitude, and on a linear scale otherwise.
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure. If None, a heuristic is used to determine the figure size.
        fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure is created.
        ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis is created.
        savePath : string
            A string containing the path to save the figure to.  If None, the figure is not saved.
        
    Output:
        fig : matplotlib figure object
            A figure object containing the bar plot of the number of null values for each field.
    """  
    import matplotlib.pyplot as plt
    # import ticker to set the y axis to log scale
    import matplotlib.ticker as ticker
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)
    else :
        # if a figure was provided, but no axis, create a new axis
        if ax is None:
            ax = fig.add_subplot(111)
    
    # in any case parse the figSize input
    if figSize is None:
        # figSizeHeuristic(longAxisItemNum,targetAxis,aspectRatio=3,heuristicFontSize = 30,heuristicFontBuffer = 2,heuristicMarginAlotment = 12)
        figSize=figSizeHeuristic(len(dataCompletenessDF),targetAxis='x',aspectRatio=1.5,heuristicFontSize = 16, heuristicFontBuffer = 4)
      
    # check to ensure that the input fig size is tuple, list, or array of length 2
    # and then convert it to a tuple
    if type(figSize) in [list,tuple,np.ndarray] and len(figSize) == 2:
        figSize = tuple(figSize)
        # if the user provided a figure size, use that
        figSize = figSize
    else :
        # throw an error about not understanding the input format
        raise ValueError('The input figSize must be a tuple, list, or array of length 2')
    # set the figure size
    fig.set_size_inches(figSize)
    

    # remove the row with the total number of records assessed, 'totalNumRecords', as we do not need this plotted
    dataCompletenessDF = dataCompletenessDF[dataCompletenessDF['fieldName'] != 'totalNumRecords']

    # iterate through the contents of the dataCompletenessDF['fieldName'] and use the insertNewlineHeuristic function to insert newlines into the long field names
    for i,fieldName in enumerate(dataCompletenessDF['fieldName']):
        # insert newlines into the long field names
        dataCompletenessDF.loc[i,'fieldName'] = insertNewlineHeuristic(fieldName,24)


    """
    NOTE: don't bother with this for now
    # determine if the field names look like camel case, and if so, add a newline before the third capital if the line is more than 30 characters long
    # first, get the length of the field names
    fieldNameLengths = dataCompletenessDF['fieldName'].str.len()
    # get the indices of the field names that are longer than 30 characters
    longFieldNames = fieldNameLengths > 30
    # get the field names that are longer than 30 characters
    longFieldNames = dataCompletenessDF.loc[longFieldNames,'fieldName']
    # get the indices of the field names that are camel case
    camelCaseFieldNames = longFieldNames.str.contains('[a-z][A-Z]')
    # get the field names that are camel case
    camelCaseFieldNames = longFieldNames.loc[camelCaseFieldNames]
    # get the indices of the field names that are camel case and longer than 30 characters
    camelCaseFieldNames = camelCaseFieldNames.index
    # add a newline before the third capital letter
    dataCompletenessDF.loc[camelCaseFieldNames,'fieldName'] = dataCompletenessDF.loc[camelCaseFieldNames,'fieldName'].str.replace('([a-z])([A-Z])','\\1\n\\2',regex=True)
    #hopefully that should prevent a bit of clutter
    """

    # get the min value and max value of the data
    minVal = np.min(dataCompletenessDF['numEmpty'])
    maxVal = np.max(dataCompletenessDF['numEmpty'])
    # because we are doing division later, if the minimum value is zero, set it to one
    if minVal == 0:
        minVal = 1

    # plot the data, but implement the log-scale logic
    if logScale==True:
        sns.barplot(x='fieldName',y='numEmpty',data=dataCompletenessDF,ax=ax,log=True)
    # handle the None / infer case
    elif logScale==None:
        # if the maximum value is more than three orders of magnitude greater than the minimum non-zero value, use a log base 10 scale
        # also add minor tics if there are fewer than 4 orders of magnitude between the minimum and maximum values
        if np.log10(maxVal/minVal) > 3:
            sns.barplot(x='fieldName',y='numEmpty',data=dataCompletenessDF,ax=ax,log=True)
            # add minor tics at the integer values of the log scale if there are fewer than 4 orders of magnitude between the minimum and maximum values
            # add faint horizontal lines aligned with the major tics
            ax.yaxis.grid(True,which='major',linestyle='--',alpha=.5,color='cadetblue',linewidth=2)
            if np.log10(maxVal/minVal) <= 5:
                ax.xaxis.set_minor_locator(ticker.LogLocator(base=10.0,subs=np.arange(1,10)*.1))
                # add faint horizontal lines aligned with the minor tics
                ax.yaxis.grid(True,which='minor',linestyle='--',alpha=.5,color='powderblue',linewidth=1)
        # otherwise, use a linear scale
        else:
            sns.barplot(x='fieldName',y='numEmpty',data=dataCompletenessDF,ax=ax)
    # handle the implicit False case
    else : 
        sns.barplot(x='fieldName',y='numEmpty',data=dataCompletenessDF,ax=ax)
    # set the y-axis limits
    #ax.set_ylim([0,maxVal])
    # set the x axis labels to be rotated 60 degrees
    # NOTE: this doesn't work because it messes up the alignment of the x axis labels with the x axis tics
    ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
    # set the title
    ax.set_title('Number of null values per field')
    # set the y axis label
    ax.set_ylabel('Number of null values')
    # set the x axis label
    ax.set_xlabel('Field name')


    # make sure the figure bounds are sufficiently generous so as to not cut off any text
    fig.tight_layout()



    # TODO: implement some adaptivness here to log scale the y axis if a sufficient number of values are too small relative to the max value
    
    return fig

def figSizeHeuristic(longAxisItemNum,targetAxis,aspectRatio=3,heuristicFontSize = 10,heuristicFontBuffer = 2,heuristicMarginAlotment = 12):
    """
    A heuristic to determine the appropriate figure size for a given number of items along the long axis of the figure.
    The goal is to make sure that the figure is large enough to contain all of the text without cutting it off or overlapping it.

    Parameters
    ----------
    longAxisItemNum : int
        The number of items along the long axis of the figure.
    targetAxis : str
        The axis that is the target of the heuristic. Must be either 'x' or 'y' or integer indices 0 or 1 corresponding to 'x' and 'y' respectively.
    aspectRatio : float
        The aspect ratio of the figure.  Which is the ratio of the long axis to the short axis.  Defaults to 3.
    heuristicFontSize : int
        The font size to use in the heuristic.  Defaults to 10. Which is the default font size in matplotlib.
    heuristicFontBuffer : int
        The buffer to use in the heuristic.  Defaults to 2.
    heuristicMarginAlotment : int
        The number of characters worth of space to leave on the long axis margin.  Defaults to 12.  
        For example, this would be to accomidate the y axis tic labels and the y axis label in the case of the x axis being the long axis.

    Returns
    -------
    figSize : tuple
        The resultant figure size in inches.  This is a tuple of the form (width,height).
    """
    # set the font size to inches conversion factor
    fontSizeToInches = 1/72

    # first, check that the targetAxis is valid
    if targetAxis not in ['x','y',0,1]:
        raise ValueError('targetAxis must be either \'x\' or \'y\' or integer indices 0 or 1 corresponding to \'x\' and \'y\' respectively.')
    # if the targetAxis is 'x' or 0, then we are targeting the x axis
    if targetAxis in ['x',0]:
        # the heuristic plot body width is the number of items along the long axis times the font size plus the buffer
        heuristicBodyWidth = longAxisItemNum*(heuristicFontSize+heuristicFontBuffer)
        # however, we also want to leave some space on the margins
        fullWidth = heuristicBodyWidth + ( heuristicMarginAlotment*heuristicFontSize )
        # this is in units of font size, so convert to inches
        fullWidth = fullWidth*fontSizeToInches
        # now that we have this, compute the implied height of the figure in inches, as this is the unit that matplotlib uses takes as input (by default)
        fullHeight = fullWidth/aspectRatio
        # return the figure size
        return (fullWidth,fullHeight)
    # if the targetAxis is 'y' or 1, then we are targeting the y axis
    elif targetAxis in ['y',1]:
        # the heuristic plot body height is the number of items along the long axis times the font size plus the buffer
        heuristicBodyHeight = longAxisItemNum*(heuristicFontSize+heuristicFontBuffer)
        # however, we also want to leave some space on the margins
        fullHeight = heuristicBodyHeight + ( heuristicMarginAlotment*heuristicFontSize )
        # this is in units of font size, so convert to inches
        fullHeight = fullHeight*fontSizeToInches
        # now that we have this, compute the implied width of the figure in inches, as this is the unit that matplotlib uses takes as input (by default)
        fullWidth = fullHeight*aspectRatio
        # return the figure size
        return (fullWidth,fullHeight)
    # if we get here, something went wrong
    else:
        raise ValueError('targetAxis must be either \'x\' or \'y\' or integer indices 0 or 1 corresponding to \'x\' and \'y\' respectively.')



def insertNewlineHeuristic(fieldName,minLength=24):
    """
    Takes a string, which presumably corresponds to a tick label in a plot, and finds an effective location to insert a 
    newline character in a manner that preserves space and symmetry.  The fieldname (input as a string) is presumed to
    have underscores and / or camel case in it.  Underscores will be pursued as the first option, and if none are found,
    the camel case option will be pursued.  If neither are found, the original string will be returned.

    input:
        fieldName : str
            A string corresponding to a field name, presumably a tick label in a plot.  The string is presumed to have
            underscores and / or camel case in it.
        minLength : int
            The minimum length of the string before a newline will be inserted.  If the string is shorter than this, the
            original string will be returned.

    output:
        newFieldName : str
            A string corresponding to the input string, but with a newline inserted in a manner that preserves space and
            symmetry.  If no suitable location for a newline is found, the original string will be returned.
    """
    import numpy as np

    # if the field name is shorter than the minimum length, return the original field name
    if len(fieldName) < minLength:
        return fieldName
    # otherwise, proceed
    else:
        # find the indexes of the underscores in the current field name
        currentUnderscoreIndices = [j for j in range(len(fieldName)) if fieldName[j] == '_']
        # from the outset we'll need the middle index of the field name
        middleOfLongFieldName = int(np.floor(len(fieldName)/2))

        # if there's at least one underscore, then we can proceed
        if len(currentUnderscoreIndices) == 0:
            # otherwise, we need to find a workaround that allows us to split the field name into two lines in a roughly equal way
            # in such a case let's assume the fieldNames are camel case, and find the indexes of all capital letters preceded by a lowercase letter
            # first, get the indexes of all capital letters
            capitalLetterIndices = [j for j in range(len(fieldName)) if fieldName[j].isupper()]
            # now, get the indexes of all capital letters preceded by a lowercase letter
            # initialize a list to hold these indices
            capitalLetterIndicesPrecededByLowercase = []
            # loop through the capital letter indices
            for j in range(len(capitalLetterIndices)):
                # if the current capital letter index is not the first index
                if capitalLetterIndices[j] > 0:
                    # if the character at the index before the current capital letter index is lowercase
                    if fieldName[capitalLetterIndices[j]-1].islower():
                        # add this index to the list
                        capitalLetterIndicesPrecededByLowercase.append(capitalLetterIndices[j])
            # now, we have a list of all capital letter indices preceded by a lowercase letter
            # we want to find the index that is closest to the middle of the field name
            
            # now, ASSUMING THAT capitalLetterIndicesPrecededByLowercase is not empty, find the difference between the middle of the field name and each of the indices in capitalLetterIndicesPrecededByLowercase
            if len(capitalLetterIndicesPrecededByLowercase) > 0:
                # get the difference between the middle of the field name and each of the indices in capitalLetterIndicesPrecededByLowercase
                capitalMidOffsets = np.abs(middleOfLongFieldName-np.array(capitalLetterIndicesPrecededByLowercase))
                # now, get the index of the minimum difference
                newlineIndex = np.argmin(capitalMidOffsets)
                # now, insert a newline at this index, which would be after the lowercase letter and before the capital letter
                newFieldName = fieldName[:capitalLetterIndicesPrecededByLowercase[newlineIndex]]+'\n'+fieldName[capitalLetterIndicesPrecededByLowercase[newlineIndex]:]
                # and return the new field name
                return newFieldName
            # otherwise, if there are no underscores and no camel casing, just return the original field name
            else:
                return fieldName
        # otherwise, if we did manage to find an underscore, we can proceed
        else : 
        # find the difference between the middle of the field name and each of the underscore indices
            underscoreMidOffsets = np.abs(middleOfLongFieldName-np.array(currentUnderscoreIndices))
            # now, get the index of the minimum difference
            newlineIndex = np.argmin(underscoreMidOffsets)
            # now, insert a newline to replace the underscore at this index
            newFieldName = fieldName[:currentUnderscoreIndices[newlineIndex]]+'\n'+fieldName[currentUnderscoreIndices[newlineIndex]+1:]
            # and return the new field name
            return newFieldName
        
def plotWordCount_histogram(wordCountDF,figSize=None,fig=None,ax=None,binSize=3):
    """
    Takes the resultsDF from wordCountForField and plots a histogram of the word counts
    
    input:
        wordCountDF : pandas dataframe
            A pandas dataframe with two columns: 'itemID' and 'wordCount'. The 'itemID' column contains the name of the input structure, and the 'wordCount'
            column contains the word count of the target field for each input structure.
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.  Default is None, which will
            attempt to auto scale based on a heuristic relevant to the input data.
        fig : matplotlib figure object
            A figure object to plot the histogram on.  If None, a new figure will be created.
        ax : matplotlib axis object
            An axis object to plot the histogram on.  If None, a new axis will be created.
        binSize : int
            The size of the bins to use for the histogram.  Default is 3.
    
    returns:
        fig : matplotlib figure object
            A figure object containing the histogram of the word counts
    
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if necessary
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)
    else :
        # if a figure was provided, but no axis, create a new axis
        if ax is None:
            ax = fig.add_subplot(111)
    
    # in any case parse the figSize input
    if figSize is None:
        # is there a heuristic for the current plot case?  In that this is simply a histogram, and we don't really need to worry about a cluttering of tic labels, no
        # so just set it to 10,5
        figSize = (10,5)
    # check to ensure that it's a tuple, list, or array of length 2
    # and then convert it to a tuple
    if type(figSize) in [list,tuple,np.ndarray] and len(figSize) == 2:
        figSize = tuple(figSize)
        # if the user provided a figure size, use that
        figSize = figSize
    else :
        # throw an error about not understanding the input format
        raise ValueError('The input figSize must be a tuple, list, or array of length 2')
    # set the figure size
    fig.set_size_inches(figSize)

    # plot the data
    # starting at 1, go up to the max word count in steps of binSize
    sns.histplot(wordCountDF['wordCount'],bins=np.arange(1,wordCountDF['wordCount'].max()+binSize,binSize),kde=False,ax=ax)
    # set the title
    ax.set_title('Word count histogram')
    # set the x axis label
    ax.set_xlabel('Word count')
    # set the y axis label
    ax.set_ylabel('Number of entries')

    # compute the mean and median of the word counts
    meanCount = np.mean(wordCountDF['wordCount'])
    medianCount = np.median(wordCountDF['wordCount'])
    # add a short red (for mean) and green (for median) vertical line to indicate both of these values
    # label the the end of the bar with the appropriate symbol for each of these
    # x with a bar on top for the mean, and μ with 1/2 subscript for the median
    # the lines should be slightly thicker than the default
    # and should only extend about 10% of the way up the y axis
    ax.vlines(meanCount,0,0.1*ax.get_ylim()[1],color='r',linewidth=4,label='x̄')
    ax.vlines(medianCount,0,0.1*ax.get_ylim()[1],color='g',linewidth=4,label='μ₁/₂')

    # the labels aren't really showing up, so add a legend for the added lines.  Also include the specific values of the mean and median in the legend
    ax.legend(title='Mean and median',loc='upper right',fontsize=14)
    # change the content of the legend entries to also include the mean and median values
    # get the current legend entries
    legendEntries = ax.get_legend_handles_labels()
    # change the legend entries to include the mean and median values
    legendEntries[1][0] = legendEntries[1][0] + ' = ' + str(round(meanCount,2))
    legendEntries[1][1] = legendEntries[1][1] + ' = ' + str(round(medianCount,2))
    # reset the legend entries
    ax.legend(legendEntries[0],legendEntries[1],title='Mean and median',loc='upper right',fontsize=14)


    return fig

def keywordCount_barPlot(keywordCountDF,figSize=None,fig=None,ax=None,logScale=False,figSavePath=None):
    """
    This function takes in the keywordCount dataframe from analyzeData.countsFromCoOccurrenceMatrix
    and produces a seaborn bar plot of the number of occurrences of each keyword.
    The column headers for the keywordCountDF should be:

    (from the docstring for analyzeData.countsFromCoOccurrenceMatrix)
    'itemID' and 'count'. The 'itemID' column contains the label of the row or column of the input matrix, and the 'count'
        column contains the count of the number of times each item occurs in the in the input matrix. 
    
    Input:
        keywordCountDF : pandas dataframe
            A pandas dataframe with two columns: 'itemID' and 'count'. The 'itemID' column contains the label of the row or column of the input matrix, and the 'count'
            column contains the count of the number of times each item occurs in the in the input matrix. 
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.'
        fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        logScale : boolean
            A boolean indicating whether to use a log scale for the y axis.  If True, the y axis will be log scaled.  If False, the y axis will not be log scaled.
            If None, a 3 order of magnitude heuristic will be used to determine whether to use a log scale or not. 
        figSavePath : string
            A string containing the path to save the figure to.  If None, the figure will not be saved.

    Output:
        fig : matplotlib figure object
            A figure object containing the bar plot of the number of occurrences of each keyword.
        ax : matplotlib axis object
            An axis object containing the bar plot of the number of occurrences of each keyword.
    """
    import matplotlib.pyplot as plt
    import matplotlib.ticker as ticker
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)
    else :
        # if a figure was provided, but no axis, create a new axis
        if ax is None:
            ax = fig.add_subplot(111)
    
    # in any case parse the figSize input
    if figSize is None:
        # figSizeHeuristic(longAxisItemNum,targetAxis,aspectRatio=3,heuristicFontSize = 10,heuristicFontBuffer = 2,heuristicMarginAlotment = 12)
        figSize=figSizeHeuristic(len(keywordCountDF),targetAxis='x',aspectRatio=3,heuristicFontBuffer = 3)

    # check to ensure that the input fig size is tuple, list, or array of length 2
    # and then convert it to a tuple
    if type(figSize) in [list,tuple,np.ndarray] and len(figSize) == 2:
        figSize = tuple(figSize)
        # if the user provided a figure size, use that
        figSize = figSize
    else :
        # throw an error about not understanding the input format
        raise ValueError('The input figSize must be a tuple, list, or array of length 2')
    # set the figure size
    fig.set_size_inches(figSize)

    # compute the minimum and maximum values of the count column
    minVal = keywordCountDF['count'].min()
    maxVal = keywordCountDF['count'].max()
    # because we are doing division later, if the minimum value is zero, set it to one
    if minVal == 0:
        minVal = 1

    # plot the data, but implement the log-scale logic
    if logScale==True:
        sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax,log=True)
    # handle the None / infer case
    elif logScale==None:
        # if the maximum value is more than three orders of magnitude greater than the minimum non-zero value, use a log base 10 scale
        # also add minor tics if there are fewer than 4 orders of magnitude between the minimum and maximum values
        if np.log10(maxVal/minVal) > 3:
            sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax,log=True)
            # add faint horizontal lines aligned with the major tics
            ax.yaxis.grid(True,which='major',linestyle='--',alpha=.5,color='cadetblue',linewidth=2)
            # add minor tics at the integer values of the log scale if there are fewer than 4 orders of magnitude between the minimum and maximum values
            if np.log10(maxVal/minVal) <= 5:
                ax.xaxis.set_minor_locator(ticker.LogLocator(base=10.0,subs=np.arange(1,10)*.1))
                # add faint horizontal lines aligned with the minor tics
                ax.yaxis.grid(True,which='minor',linestyle='--',alpha=.5,color='powderblue',linewidth=1)

                # otherwise it would be too crowded, so don't add minor tics
            else:
                pass
        # otherwise, use a linear scale
        else:
            sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax,log=False)
    # handle the implicit False case
    else : 
        sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax,log=False)

    # set the x axis labels to be rotated 60 degrees
    # NOTE: this doesn't work because it messes up the alignment of the x axis labels with the x axis tics
    ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
    # set the title
    ax.set_title('Keyword counts')
    # set the y axis label
    ax.set_ylabel('Number of occurrences')
    # set the x axis label
    ax.set_xlabel('Keyword')

    # there shouldn't be any exceptionally long keywords, nor any multi line keywords, so no need to do any special formatting here

    # save the figure if a save path was provided
    if figSavePath is not None:
        fig.savefig(figSavePath,bbox_inches='tight')
        

    return fig,ax

def coOccurrenceMatrix_heatmapPlot(matrixDF,rowTitle='',colTitle='',figSize=None,fig=None,ax=None,colorMap='viridis',logScale=False,figSavePath=None):
    """
    This function takes in a matrix-like pandas dataframe and generates a heat map plot of the data.

    Inputs:
        matrixDF : pandas dataframe
            A pandas dataframe containing the matrix data to plot.  The index and column names will be used as the row and column labels, so make sure they are set appropriately.
        rowTitle : string
            A string containing the title for the vertical axis of the matrix / plot.  If None or '' then no axis label will be applied.
        colTitle : string
            A string containing the title for the horizontal axis of the matrix / plot.  If None or '' then no axis label will be applied.
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.
            If None, a heuristic will be used to determine the figure size.
        fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        colorMap : string
            A string containing the name of the color map to use for the heat map.  See https://matplotlib.org/stable/tutorials/colors/colormaps.html for a list of available color maps.
        logScale : boolean
            A boolean indicating whether to use a log scale for the color map.  If True, the color map will be log scaled.  If False, the color map will not be log scaled.
            If None, a two order of magnitude heuristic will be used to determine whether to use a log scale.
        figSavePath : string
            A string containing the path to save the figure to.  If None, the figure will not be saved.
            
    Outputs:
        fig : matplotlib figure object
            A figure object containing the heat map plot of the matrix data.
        ax : matplotlib axis object
            An axis object containing the heat map plot of the matrix data.

    """
    import matplotlib.pyplot as plt
    import matplotlib
    import seaborn as sns
    import numpy as np

   # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)
    else :
        # if a figure was provided, but no axis, create a new axis
        if ax is None:
            ax = fig.add_subplot(111)
    
    # in any case parse the figSize input
    if figSize is None:
        # figSizeHeuristic(longAxisItemNum,targetAxis,aspectRatio=3,heuristicFontSize = 10,heuristicFontBuffer = 2,heuristicMarginAlotment = 12)
        figSize=figSizeHeuristic(len(matrixDF),targetAxis='x',aspectRatio=1,heuristicFontSize = 10)

    # check to ensure that the input fig size is tuple, list, or array of length 2
    # and then convert it to a tuple
    if type(figSize) in [list,tuple,np.ndarray] and len(figSize) == 2:
        figSize = tuple(figSize)
        # if the user provided a figure size, use that
        figSize = figSize
    else :
        # throw an error about not understanding the input format
        raise ValueError('The input figSize must be a tuple, list, or array of length 2')
    # set the figure size
    fig.set_size_inches(figSize)
    # for the sake of readability, if the minimum value in the matrix is zero, we will set these entries to NaN so that the color map doesn't get swamped by the zeros
    # first, get the minimum value and maximum value in the matrix
    minVal = matrixDF.min().min()
    maxVal = matrixDF.max().max()

    # if the minimum value is zero (i.e. the matrix is non-negative), set the zeros to NaN as they would otherwise overwhelm the heat map
    if minVal == 0:
        matrixDF[matrixDF == 0] = np.nan

    # now that we are done masking, 
    # because we are doing division later, if the minimum value is zero, set it to one
    if minVal == 0:
        minVal = 1


    # plot the data, but implement the log-scale logic
    if logScale==True:
        # previously: sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,norm=matplotlib.colors.LogNorm())
        # also, ensure that tic labels are provided for each cell of both the x and y axes
        sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,norm=matplotlib.colors.LogNorm(),xticklabels=True,yticklabels=True)
    # handle the None / infer case
    elif logScale==None:
        # if the maximum value is more than two orders of magnitude greater than the minimum non-zero value, use a log base 10 scale
        
        if np.log10(maxVal/minVal) > 2:
            sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,norm=matplotlib.colors.LogNorm(),xticklabels=True,yticklabels=True)
        # otherwise, use a linear color map
        else:
            sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,xticklabels=True,yticklabels=True)
    # handle the implicit False case
    else : 
        sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,xticklabels=True,yticklabels=True)

    # compute a scaling factor for the major plot and key lablels based on the current figure size
    currentWidth = fig.get_size_inches()[0]
    # font size is 1/72 of an inch, so we will use this to scale the font size
    # lets pretend like we want 30 chracters worth of these labels to occupy 1/3 of the figure width
    inchesPerTitleChar = (currentWidth/3)/15
    # now convert this to points
    targetFontSize = inchesPerTitleChar*72


    # set the titles
    ax.set_title('Co-occurrence matrix for\n' + rowTitle + ' by ' + colTitle)
    # set the title font size
    ax.title.set_fontsize(targetFontSize)
    # set the y axis label
    ax.set_ylabel(rowTitle)
    # set the y axis label font size
    ax.yaxis.label.set_fontsize(targetFontSize)
    # set the x axis label
    ax.set_xlabel(colTitle)
    # set the x axis label font size
    ax.xaxis.label.set_fontsize(targetFontSize)

    # change the font size of the color bar tic labels and the color bar label
    # first, get the color bar axis
    cbar = ax.collections[0].colorbar
    # set the color bar label font size
    cbar.ax.set_ylabel('Occurrence count',fontsize=targetFontSize)
    # set the color bar tic label font size, but half it and round down to an integer
    cbar.ax.tick_params(labelsize=targetFontSize)

    # seaborn defaults to trying to reduce the number of ticks on the x axis, which is not what we want here, so we will set the x axis ticks manually
    # first, get the number of columns in the matrix

    # get the labels as a list, they should be the same for both axes
    labels = list(matrixDF.columns)

    # to compensate for lots of text, lets set the tic labels to be slightly smaller than default
    ax.tick_params(axis='x',labelsize=10)
    # seaborn also places the x tics at the boundaries of the cells, which is not what we want here, so we will set the x axis tics to be in the middle of the cells
    # first, get the width of the x axis
    #xWidth = np.abs(ax.get_xlim()[1] - ax.get_xlim()[0])
    #debug print
    #print('xWidth is ' + str(xWidth))
    # set the x axis tics to be in the middle of the cells
    # debug print
    #print('np.arange(0.5,xWidth,1) is ' + str(np.arange(0.5,xWidth,1)))
    #ax.set_xticks(np.arange(0.5,xWidth,1))


    # for whatever reason the x tic labels are no longer showing up, perhaps because manipulating them has reset them, so lets ensure we set them manually here
    #ax.set_xticklabels(labels)

    # likewise, ensure that there are y axis tics for every row, and that they are in the middle of the cells
    ax.tick_params(axis='y',labelsize=10)
    # first, get the height of the y axis
    # y axis must be specified using a negative frame of reference for some reason
    #yHeight = ax.get_ylim()[1] - ax.get_ylim()[0]
    # set the y axis tics to be in the middle of the cells
    #ax.set_yticks(np.arange(-0.5,yHeight,-1))
    
    # now set the y axis tic labels
    #ax.set_yticklabels(labels)
    
    # save the figure if a save path was provided
    if figSavePath is not None:
        # if it is '', then save using the default name
        if figSavePath == '':
            defaultName='coOccurrenceMatrix_' + rowTitle + '_by_' + colTitle + '.png'
            figSavePath = defaultName
        # in any case you should have the figure name by now, so save it
        fig.savefig(figSavePath,bbox_inches='tight')
    
    # return the figure and axis objects
    return fig,ax 

def matrix_histogramCounts(inputMatrix,keepAxis='columns',dropZero=True,binSize=1,figSize=(10,5),fig=None,ax=None,figSavePath=None):
    """
    This function takes in a matrix (either a pandas dataframe or numpy array) and generates a histogram of the counts obtained from summing across
    the UNREQUESTED axis (the axis that is not kept) of the matrix.  The counts are then binned and plotted as a histogram.
    
    Inputs
        - inputMatrix : pandas dataframe or numpy array
            A matrix-like object to generate the histogram from.
        - keepAxis : string
            A string containing either 'rows' or 'columns' to indicate which axis to keep when summing across the other axis.
        - dropZero : boolean
            A boolean indicating whether to drop the zero counts from the histogram.  This would be to avoid zeros from swamping the visualization.  If True, the zeros will be dropped and not featured in the plot.
        - binSize : int
            An integer indicating the size of the bins to use for the histogram.
        - figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.'
        - fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        - ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        - figSavePath : string 
            A string containing the path to save the figure to.  If None, the figure will not be saved.

    Outputs
        - fig : matplotlib figure object
            A figure object containing the histogram of the counts.
        - ax : matplotlib axis object
            An axis object containing the histogram of the counts.
        - countsDF : pandas dataframe
            A pandas dataframe containing the counts associated with the input matrix.  The first column is the count value, and the second column is the number of times that count value was observed.
    
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)

    # if the input matrix is a pandas dataframe, then we will convert it to a numpy array
    if isinstance(inputMatrix,pd.DataFrame):
        inputMatrix = inputMatrix.values

    # sum across the axis that is not kept, but be robust to the input matrix being a numpy array or pandas dataframe
    if keepAxis == 'rows':
        # sum across the columns
        counts = inputMatrix.sum(axis=1)
    elif keepAxis == 'columns' or keepAxis == 'cols':
        # sum across the rows
        counts = inputMatrix.sum(axis=0)
    else:
        raise ValueError('keepAxis must be either "rows" or "columns"')
    
    # convert the counts to a pandas dataframe
    countsDF = pd.DataFrame(counts,columns=['count'])
    # get the number of times each count value was observed
    countsDF = countsDF['count'].value_counts().reset_index()
    # rename the columns
    countsDF.columns = ['count','numObserved']
    
    # we will create a temporary dataframe that we will plot from, which takes in to account the `dropZero` parameter
    # if dropZero is True, then we will drop the zero counts from the dataframe for plotting
    # if dropZero is False, then we will not drop the zero counts from the dataframe for plotting
    # regardless, the output dataframe will contain all of the counts
    if dropZero:
        # if there is a row with zero in the counts, which would correspond to those records without any keyword hits, drop it.
        if 0 in countsDF['count'].values:
            plotDF = countsDF[countsDF['count'] != 0]
        else:
            plotDF = countsDF
        startNum = min(plotDF['count'])
    else:
        # don't drop the zero counts
        plotDF = countsDF
        startNum = 0
    print(plotDF.head())
    # plot the data, but remember we want the tic marks and tick labels to be in the middle of the bins, and for the label values to reflect what would have been the left bin edge
    sns.histplot(data=plotDF,x='count',weights='numObserved',bins=np.arange(0,np.max(np.max(plotDF['count'])),binSize),kde=False,ax=ax)
      #(data=plotDF,x='counts',bins=np.arange(0,np.max(counts)+binSize,binSize),kde=False,ax=ax)   
    # make sure the x tics are in the middle of the bins rather than at the edges
    ax.set_xticks(np.arange(startNum+0.5*binSize,np.max(plotDF['count']),binSize))
    # however, even though the x tics are in the middle of the bins, they should still be labeled with the bin edges, as integers
    ax.set_xticklabels(np.arange(startNum,np.max(plotDF['count']),binSize,dtype=int))
    # set the title
    ax.set_title('Histogram of counts')
    
    # set the x axis label
    ax.set_xlabel('Count')
    # set the y axis label
    ax.set_ylabel('Number of occurrences')
    # compute the mean and median of the counts
    meanCount = np.mean(counts) 
    medianCount = np.median(counts)
    # add a short red (for mean) and green (for median) vertical line to indicate both of these values
    # label the the end of the bar with the appropriate symbol for each of these
    # x with a bar on top for the mean, and μ with 1/2 subscript for the median
    # the lines should be slightly thicker than the default
    # and should only extend about 10% of the way up the y axis
    ax.vlines((meanCount + binSize * .5),0,0.1*ax.get_ylim()[1],color='r',linewidth=4,label='x̄')
    ax.vlines((medianCount + binSize * .5),0,0.1*ax.get_ylim()[1],color='g',linewidth=4,label='μ₁/₂')

    # the labels aren't really showing up, so add a legend for the added lines.  Also include the specific values of the mean and median in the legend
    ax.legend(title='Mean and median',loc='upper right',fontsize=14)
    # change the content of the legend entries to also include the mean and median values
    # get the current legend entries
    legendEntries = ax.get_legend_handles_labels()
    # change the legend entries to include the mean and median values
    legendEntries[1][0] = legendEntries[1][0] + ' = ' + str(round(meanCount,2))
    legendEntries[1][1] = legendEntries[1][1] + ' = ' + str(round(medianCount,2))
    # reset the legend entries
    ax.legend(legendEntries[0],legendEntries[1],title='Mean and median',loc='upper right',fontsize=14)


    # save the figure if a save path was provided
    if figSavePath is not None:
        # if it is '', then save using the default name
        if figSavePath == '':
            defaultName='matrixHistogram_' + keepAxis + '.png'
            figSavePath = defaultName
        # in any case you should have the figure name by now, so save it
        fig.savefig(figSavePath,bbox_inches='tight')

    # return the figure and axis objects
    return fig,ax,countsDF
