"""
This set of functions is for the production of figures


"""

def plotNullValue_barPlot(dataCompletenessDF,figSize=(10,5)):
    """
    This function takes in the table generated by analyzeData.quantifyDataCompleteness, which outputs:

    dataCompletenessDF : pandas dataframe
        A pandas dataframe with two columns:  the first column is the field name and the second column is the number of empty / null values for that field.
        The last row is the total number of records assessed.

    and produces a seaborn-based bar plot of the number of null values for each field.
    The last row is omitted from the plot, as it is the total number of records assessed, 
    but it is used to set the y-axis limits.

    Input:
        dataCompletenessDF : pandas dataframe
            A pandas dataframe with two columns:  the first column is ('fieldName'): the field name and the second column ('numEmpty') is the number of empty / null values for that field.
            The last row is the total number of records assessed.  Generated by analyzeData.quantifyDataCompleteness
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.
        
    Output:
        fig : matplotlib figure object
            A figure object containing the bar plot of the number of null values for each field.
    """  
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # get the max value from the last row of the dataframe
    

    # remove the row with the total number of records assessed, 'totalNumRecords'
    dataCompletenessDF = dataCompletenessDF[dataCompletenessDF['fieldName'] != 'totalNumRecords']

    # create a figure
    fig,ax = plt.subplots(figsize=figSize)

    # go through the column names and remove all newlines
    dataCompletenessDF['fieldName'] = dataCompletenessDF['fieldName'].str.replace('\n','')
    # determine if the field names look like camel case, and if so, add a newline before the third capital if the line is more than 30 characters long
    # first, get the length of the field names
    fieldNameLengths = dataCompletenessDF['fieldName'].str.len()
    # get the indices of the field names that are longer than 30 characters
    longFieldNames = fieldNameLengths > 30
    # get the field names that are longer than 30 characters
    longFieldNames = dataCompletenessDF.loc[longFieldNames,'fieldName']
    # get the indices of the field names that are camel case
    camelCaseFieldNames = longFieldNames.str.contains('[a-z][A-Z]')
    # get the field names that are camel case
    camelCaseFieldNames = longFieldNames.loc[camelCaseFieldNames]
    # get the indices of the field names that are camel case and longer than 30 characters
    camelCaseFieldNames = camelCaseFieldNames.index
    # add a newline before the third capital letter
    dataCompletenessDF.loc[camelCaseFieldNames,'fieldName'] = dataCompletenessDF.loc[camelCaseFieldNames,'fieldName'].str.replace('([a-z])([A-Z])','\\1\n\\2',regex=True)
    #hopefully that should prevent a bit of clutter

    # plot the data
    sns.barplot(x='fieldName',y='numEmpty',data=dataCompletenessDF,ax=ax)
    # set the y-axis limits
    #ax.set_ylim([0,maxVal])
    # set the x axis labels to be rotated 60 degrees
    # NOTE: this doesn't work because it messes up the alignment of the x axis labels with the x axis tics
    ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
    # set the title
    ax.set_title('Number of null values per field')
    # set the y axis label
    ax.set_ylabel('Number of null values')
    # set the x axis label
    ax.set_xlabel('Field name')

    # if there were any long field names, change the font size of the x axis labels
    if len(longFieldNames) > 0:
        ax.tick_params(axis='x',labelsize=8)
        # also reduce the spacing between separate lines of text in the x axis labels by modifyin the linespacing parameter
        for label in ax.get_xticklabels():
            label.set_linespacing(0.5)

    # make sure the figure bounds are sufficiently generous so as to not cut off any text
    fig.tight_layout()



    # TODO: implement some adaptivness here to log scale the y axis if a sufficient number of values are too small relative to the max value
    
    return fig

def plotWordCount_histogram(wordCountDF,figSize=(10,5),binSize=3):
    """
    Takes the resultsDF from wordCountForField and plots a histogram of the word counts
    
    input:
        wordCountDF : pandas dataframe
            A pandas dataframe with two columns: 'itemID' and 'wordCount'. The 'itemID' column contains the name of the input structure, and the 'wordCount'
            column contains the word count of the target field for each input structure.
    
    returns:
        fig : matplotlib figure object
            A figure object containing the histogram of the word counts
    
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure
    fig,ax = plt.subplots(figsize=figSize)

    # plot the data
    # starting at 1, go up to the max word count in steps of binSize
    sns.histplot(wordCountDF['wordCount'],bins=np.arange(1,wordCountDF['wordCount'].max()+binSize,binSize),kde=False,ax=ax)
    # set the title
    ax.set_title('Word count histogram')
    # set the x axis label
    ax.set_xlabel('Word count')
    # set the y axis label
    ax.set_ylabel('Number of entries')

    return fig

def keywordCount_barPlot(keywordCountDF,figSize=(10,5),fig=None,ax=None,logScale=False,figSavePath=None):
    """
    This function takes in the keywordCount dataframe from analyzeData.countsFromCoOccurrenceMatrix
    and produces a seaborn bar plot of the number of occurrences of each keyword.
    The column headers for the keywordCountDF should be:

    (from the docstring for analyzeData.countsFromCoOccurrenceMatrix)
    'itemID' and 'count'. The 'itemID' column contains the label of the row or column of the input matrix, and the 'count'
        column contains the count of the number of times each item occurs in the in the input matrix. 
    
    Input:
        keywordCountDF : pandas dataframe
            A pandas dataframe with two columns: 'itemID' and 'count'. The 'itemID' column contains the label of the row or column of the input matrix, and the 'count'
            column contains the count of the number of times each item occurs in the in the input matrix. 
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.'
        fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        logScale : boolean
            A boolean indicating whether to use a log scale for the y axis.  If True, the y axis will be log scaled.  If False, the y axis will not be log scaled.
        figSavePath : string
            A string containing the path to save the figure to.  If None, the figure will not be saved.

    Output:
        fig : matplotlib figure object
            A figure object containing the bar plot of the number of occurrences of each keyword.
        ax : matplotlib axis object
            An axis object containing the bar plot of the number of occurrences of each keyword.
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)

    # plot the data
    if logScale :
        sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax,log=True)
    else :
        sns.barplot(x='itemID',y='count',data=keywordCountDF,ax=ax)
    # set the x axis labels to be rotated 60 degrees
    # NOTE: this doesn't work because it messes up the alignment of the x axis labels with the x axis tics
    ax.set_xticklabels(ax.get_xticklabels(),rotation=90)
    # set the title
    ax.set_title('Keyword counts')
    # set the y axis label
    ax.set_ylabel('Number of occurrences')
    # set the x axis label
    ax.set_xlabel('Keyword')

    # there shouldn't be any exceptionally long keywords, nor any multi line keywords, so no need to do any special formatting here

    # save the figure if a save path was provided
    if figSavePath is not None:
        fig.savefig(figSavePath,bbox_inches='tight')
        

    return fig,ax

def coOccurrenceMatrix_heatmapPlot(matrixDF,rowTitle='',colTitle='',figSize=(6.5,5),fig=None,ax=None,colorMap='viridis',logScale=False,figSavePath=None):
    """
    This function takes in a matrix-like pandas dataframe and generates a heat map plot of the data.

    Inputs:
        matrixDF : pandas dataframe
            A pandas dataframe containing the matrix data to plot.  The index and column names will be used as the row and column labels, so make sure they are set appropriately.
        rowTitle : string
            A string containing the title for the vertical axis of the matrix / plot.  If None or '' then no axis label will be applied.
        colTitle : string
            A string containing the title for the horizontal axis of the matrix / plot.  If None or '' then no axis label will be applied.
        figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.'
        fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        colorMap : string
            A string containing the name of the color map to use for the heat map.  See https://matplotlib.org/stable/tutorials/colors/colormaps.html for a list of available color maps.
        logScale : boolean
            A boolean indicating whether to use a log scale for the color map.  If True, the color map will be log scaled.  If False, the color map will not be log scaled.
        figSavePath : string
            A string containing the path to save the figure to.  If None, the figure will not be saved.
            
    Outputs:
        fig : matplotlib figure object
            A figure object containing the heat map plot of the matrix data.
        ax : matplotlib axis object
            An axis object containing the heat map plot of the matrix data.

    """
    import matplotlib.pyplot as plt
    import matplotlib
    import seaborn as sns
    import numpy as np

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)

    # for the sake of readability, if the minimum value in the matrix is zero, we will set these entries to NaN so that the color map doesn't get swamped by the zeros
    # first, get the minimum value in the matrix
    minVal = matrixDF.min().min()
    # if the minimum value is zero, then set the zero entries to NaN
    if minVal == 0:
        matrixDF[matrixDF == 0] = np.nan

    # plot the data
    if logScale:
        sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True,norm=matplotlib.colors.LogNorm())
    else:
        sns.heatmap(matrixDF,ax=ax,cmap=colorMap, cbar_kws={'label': 'Occurrence count'}, cbar=True)
    # set the titles
    ax.set_title('Co-occurrence matrix for ' + rowTitle + ' by ' + colTitle)
    # set the y axis label
    ax.set_ylabel(rowTitle)
    # set the x axis label
    ax.set_xlabel(colTitle)
    # seaborn defaults to trying to reduce the number of ticks on the x axis, which is not what we want here, so we will set the x axis ticks manually
    # first, get the number of columns in the matrix
    numCols = matrixDF.shape[1]
    # set the x axis ticks to be every column
    ax.set_xticks(range(numCols))
    # set the x axis tick labels to be the column names
    ax.set_xticklabels(matrixDF.columns)
    # to compensate for lots of text, lets set the tic labels to be slightly smaller than default
    ax.tick_params(axis='x',labelsize=8)
    # seaborn also places the x tics at the boundaries of the cells, which is not what we want here, so we will set the x axis tics to be in the middle of the cells
    # first, get the width of the x axis
    xWidth = ax.get_xlim()[1] - ax.get_xlim()[0]
    # set the x axis tics to be in the middle of the cells
    ax.set_xticks(np.arange(0.5,xWidth,1))


    # change the y axis tick labels to be slightly smaller than default
    ax.tick_params(axis='y',labelsize=8)


    # save the figure if a save path was provided
    if figSavePath is not None:
        # if it is '', then save using the default name
        if figSavePath == '':
            defaultName='coOccurrenceMatrix_' + rowTitle + '_by_' + colTitle + '.png'
            figSavePath = defaultName
        # in any case you should have the figure name by now, so save it
        fig.savefig(figSavePath,bbox_inches='tight')
    
    # return the figure and axis objects
    return fig,ax 

def matrix_histogramCounts(inputMatrix,keepAxis='columns',dropZero=True,binSize=1,figSize=(10,5),fig=None,ax=None,figSavePath=None):
    """
    This function takes in a matrix (either a pandas dataframe or numpy array) and generates a histogram of the counts obtained from summing across
    the UNREQUESTED axis (the axis that is not kept) of the matrix.  The counts are then binned and plotted as a histogram.
    
    Inputs
        - inputMatrix : pandas dataframe or numpy array
            A matrix-like object to generate the histogram from.
        - keepAxis : string
            A string containing either 'rows' or 'columns' to indicate which axis to keep when summing across the other axis.
        - dropZero : boolean
            A boolean indicating whether to drop the zero counts from the histogram.  This would be to avoid zeros from swamping the visualization.  If True, the zeros will be dropped and not featured in the plot.
        - binSize : int
            An integer indicating the size of the bins to use for the histogram.
        - figSize : tuple
            A tuple of two integers, the first being the width of the figure and the second being the height of the figure.'
        - fig : matplotlib figure object
            A figure object to plot the bar plot on.  If None, a new figure will be created.
        - ax : matplotlib axis object
            An axis object to plot the bar plot on.  If None, a new axis will be created.
        - figSavePath : string 
            A string containing the path to save the figure to.  If None, the figure will not be saved.

    Outputs
        - fig : matplotlib figure object
            A figure object containing the histogram of the counts.
        - ax : matplotlib axis object
            An axis object containing the histogram of the counts.
        - countsDF : pandas dataframe
            A pandas dataframe containing the counts associated with the input matrix.  The first column is the count value, and the second column is the number of times that count value was observed.
    
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np
    import pandas as pd

    # create a figure if one was not provided
    if fig is None:
        fig,ax = plt.subplots(figsize=figSize)

    # if the input matrix is a pandas dataframe, then we will convert it to a numpy array
    if isinstance(inputMatrix,pd.DataFrame):
        inputMatrix = inputMatrix.values

    # sum across the axis that is not kept, but be robust to the input matrix being a numpy array or pandas dataframe
    if keepAxis == 'rows':
        # sum across the columns
        counts = inputMatrix.sum(axis=1)
    elif keepAxis == 'columns' or keepAxis == 'cols':
        # sum across the rows
        counts = inputMatrix.sum(axis=0)
    else:
        raise ValueError('keepAxis must be either "rows" or "columns"')
    
    # convert the counts to a pandas dataframe
    countsDF = pd.DataFrame(counts,columns=['count'])
    # get the number of times each count value was observed
    countsDF = countsDF['count'].value_counts().reset_index()
    # rename the columns
    countsDF.columns = ['count','numObserved']
    # we will create a temporary dataframe that we will plot from, which takes in to account the `dropZero` parameter
    # if dropZero is True, then we will drop the zero counts from the dataframe for plotting
    # if dropZero is False, then we will not drop the zero counts from the dataframe for plotting
    # regardless, the output dataframe will contain all of the counts
    if dropZero:
        # drop the zero counts
        plotDF = countsDF.loc[countsDF['count'] != 0,:]
    else:
        # don't drop the zero counts
        plotDF = countsDF

    # plot the data
    sns.histplot(pd.DataFrame(data=counts,columns=['counts']),x='counts',bins=np.arange(0,np.max(counts)+binSize,binSize),kde=False,ax=ax)   
    # set the title
    ax.set_title('Histogram of counts')
    # set the x axis label
    ax.set_xlabel('Count')
    # set the y axis label
    ax.set_ylabel('Number of occurrences')

    # save the figure if a save path was provided
    if figSavePath is not None:
        # if it is '', then save using the default name
        if figSavePath == '':
            defaultName='matrixHistogram_' + keepAxis + '.png'
            figSavePath = defaultName
        # in any case you should have the figure name by now, so save it
        fig.savefig(figSavePath,bbox_inches='tight')

    # return the figure and axis objects
    return fig,ax,countsDF
